---
layout: post
background: '/assets/banner/HemkutHill_12.jpg'
status: publish
published: true
title: The cleanest cloning
author:
  name: Palash Ray
  
  email: paawak@gmail.com
  url: 'https://www.linkedin.com/in/palash-ray/'

author_email: paawak@gmail.com
wordpress_id: 18
wordpress_url: http://technoblogs.paawak.com/?p=16
date: '2008-07-11 11:37:50 +0530'
date_gmt: '2008-07-11 06:07:50 +0530'
categories:
- java
tags:
- java
comments:
- id: 5
  author: "//ikolaj"
  author_email: knb@efef.dk
  author_url: http://blog.efef.dk
  date: '2009-05-27 15:50:19 +0530'
  date_gmt: '2009-05-27 10:20:19 +0530'
  content: Succinct.
---
<p>Many a times we need to clone complex objects to promote re-using preset values while achieving perfect decoupling, as in, two identical objects but having different references to nested depths. The simplest and most elegant solution is serialization and de-serialization. Of course, there is a small catch here, the objects should be serializable. Moreover, there may be a slight performance glitch. This creates a deep-copy of the original object.<br />
I am pasting the code below:<br />
public Object createClone() throws Exception {<br />
// serialize<br />
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();<br />
ObjectOutputStream oos = new ObjectOutputStream(outputStream);<br />
oos.writeObject(this);<br />
oos.close();<br />
// de-serialize<br />
ByteArrayInputStream inputStream = new ByteArrayInputStream(<br />
outputStream.toByteArray());<br />
ObjectInputStream ois = new ObjectInputStream(inputStream);<br />
return ois.readObject();<br />
}</p>
